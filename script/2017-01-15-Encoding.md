>- 考虑一下，下面这几个说法分别是什么意思.，是不是在说同一个东西....
>    + 源代码文件的字符编码
>    + 被读取的文件的字符编码
>    + 控制台/命令行的字符编码
>    + 字符串的解码与再编码

看来这个坑得我填.

## 先说被读取的文件的字符编码

以 ch1 任务的 weather_info.txt 文件为例, 这个文件的实际编码是 utf-8 的.  
其实不止是 python, 使用任何一门编程语言, 如果想正确解析一个文件, 就必须知道文件的正确格式和编码.  
所以, 在调用`open`函数的时候, 最好的方式就是显式地去设置正确的编码格式作为参数, 不然就会出现`UnicodeDecodeError`这种错误.

但是! 只有部分同学在操作这个文件的时候遇到了编码问题. 甚至大妈给出的截图里面, `open`一个文件的时候, 也没有指定编码. Why?  
![被误读的大妈](https://cloud.githubusercontent.com/assets/22494/21803361/babf2532-d764-11e6-9a5c-1bec22a7aad0.png)

那官方文档怎么说?
> open(file, mode='r', buffering=-1, encoding=None, errors=None, newline=None, closefd=True, opener=None)

嗯. 官方说`open`方法你不跟我说`encoding`是啥, 我就给它设置一个`None`. 但是! 如果多往下看几行, 就会有新发现.

> encoding is the name of the encoding used to decode or encode the file. This should only be used in text mode. ***The default encoding is platform dependent (whatever locale.getpreferredencoding() returns)***, but any text encoding supported by Python can be used. See the codecs module for the list of supported encodings.

啥意思? 意思就是如果你没有设置这个参数的值, 那么代码在运行的时候会根据操作系统的平台自动获取. 也就是说在 Windows 上设置为`gbk`或者`cp932`之类的, 在 Mac 上, 会自动设置成 `utf-8`(当然, 这也是个默认值. 不排除有人自己改动过配置).

所以, 大妈的代码没设置`encoding`参数却能不显示乱码, 是因为读到了默认配置. 而出现乱码问题的 Mac 党, 检查一下你的`locale.getpreferredencoding()`是什么? Win 党就顺手设置一下编码参数吧, 不费事.

## 再来说源代码文件的编码

上面已经说了, 如果一个程序/代码需要正确解析文件的内容, 就必须知道格式和编码, 不然容易出现解码错误. 其实, 你在执行一个 Python 脚本的时候, 也是同样的道理.

还记得怎么在 CLI 里执行一个 Python 脚本吧?
```bash
$ python script.py
```
Python 要执行这个脚本, 首先就要做`open`的动作, 然后按照编码来解析它.   
这里面隐含的信息有:
* 既然让 python 来执行这个脚本, 那 python 就认为这个文件的格式是符合 python 语法的. 这就是`"格式"`信息.
* 在检查源代码文件的语法是不是符合要求之前, 就需要正确解析这个文件, 那就需要知道编码格式
  * 程序员的世界中, 很多时候为了省事儿, 会设置默认值.
  * 所以, 在 Python 2.x 中, 默认源代码文件的编码是`ASCII`
  * 在 Python 3.x 中, 默认源代码文件的编码是`utf-8`
* 但是, 即便是在 Python 2.x 中, 执行一个脚本文件, 也从不需要加类似于 `--encoding=utf-8` 这样的命令行参数.
  * 因为你在源代码里写了哇.

## 控制台/命令行的编码

是的, Windows 下面的 CMD, Mac/Linux 下面的各种 shell 也都是有编码设置的. 原因也是一样的, 这些程序需要正确解析相应的数据, 这样显示在屏幕上的时候, 人才可以看得懂. 乱码界有一个著名的`锟斤拷`的梗, 有兴趣的可以搜索一下.

那么, 控制台/命令行的编码会引起哪些问题呢?   
去看看 @chuanwj 同学的 [踩坑笔记](https://github.com/chuanwj/Py103/blob/master/chap1-use-chinese-in-pythonmd.md) 吧, 入坑出坑, 姿势矫健.  
另外, 还有一种实现方式, 还不会`异常处理`的同学可以试试 [这个思路](http://stackoverflow.com/questions/11068581/python-raw-input-odd-behavior-with-accents-containing-strings)


## 字符串的解码与再编码

上面的前两个问题, 讨论的都是字符串或者说数据的解码问题, 需要设置正确的编码, 才能做正确的解析. 而再编码问题, 在第三个问题里有涉及.

在 Windows 上, 你以 utf-8 的编码正确解析了 weather_info.txt 文件, 查询/输出历史记录等功能也都通了, 没啥问题. 但是在`print`上踩了坑, 为什么? 因为你的数据是`utf-8`格式的, 而`CMD`它根本不知道这事儿. 所以你得重新编码成`GBK`格式的才行.

```py
try:
    key = raw_input(u'请输入指令或您要查询的城市名：')  # 在pycharm中，因为使用了UTF-8编码，所以可以直接用
except:
    prompt = '请输入指令或您要查询的城市名: '.decode('utf-8').encode('gbk')  # 在CMD中，需要把程序里按照UTF-8编码的字符串先按照UTF-8解码，再按照GBK编码才可以显示。
    key = raw_input(prompt)
try:
    message = key.decode('utf-8')  # 为了后面进行操作，Pycharm中输入的汉字要按照UTF-8解码
except:
    message = key.decode('gbk')  #CMD中输入的汉字按照GBK进行解码
```

所以, 看一下代码里很细心的注释, 明白了吗?

没明白? 在每一行前后都加`print`, 把自己当成小黄鸭, 让程序和你说话.
